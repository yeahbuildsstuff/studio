<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>InteractiveStudio™ Builder</title>
  <style>
    body { background:#111; color:white; font-family:Arial; padding:20px; }
    button { padding:12px 20px; font-size:16px; cursor:pointer; background:#4caf50; border:none; border-radius:6px; color:white; }
  </style>
</head>
<body>

<h1>InteractiveStudio™ — Client Builder</h1>
<button onclick="buildClient()">Build & Download Client</button>

<script>

// Load defaultclient.html
async function loadDefaultClient() {
  const res = await fetch("StudioAssets/defaultclient.html");
  return await res.text();
}

// Apply modifications WITHOUT REGEX
function applyMods(html) {

  // ------------------------------------------------------------
  // 1. Replace toolDeclarations
  // ------------------------------------------------------------
  const toolStart = html.indexOf("const toolDeclarations");
  const toolOpen = html.indexOf("[", toolStart);
  const toolClose = html.indexOf("]", toolOpen);

  const newTools = `
  { type: "Grab",      name: "Grab" },
  { type: "Copy",      name: "Clone" },
  { type: "Delete",    name: "Delete" },
  { type: "SlingShot", name: "SlingShot" },
  { type: "Bomb",      name: "Explosives" }
`;

  html =
    html.substring(0, toolOpen + 1) +
    newTools +
    html.substring(toolClose);

  // ------------------------------------------------------------
  // 2. Replace ENTIRE PLACE_CODE(scene) function
  // ------------------------------------------------------------
  const placeStart = html.indexOf("function PLACE_CODE(scene)");
  const braceOpen = html.indexOf("{", placeStart);

  // Find matching closing brace
  let depth = 1;
  let i = braceOpen + 1;

  while (i < html.length && depth > 0) {
    if (html[i] === "{") depth++;
    if (html[i] === "}") depth--;
    i++;
  }

  const braceClose = i; // end of function

  const newFunction = `
function PLACE_CODE(scene) {

  // BASEPLATE
  const baseplate = BABYLON.MeshBuilder.CreateBox("Baseplate", {
    width: 64,
    height: 0.5,
    depth: 64
  }, scene);

  baseplate.position.set(0, -10, 0);

  const baseMat = new BABYLON.StandardMaterial("baseMat", scene);
  baseMat.diffuseColor = new BABYLON.Color3(0.4, 0.4, 0.4);
  baseplate.material = baseMat;

  const baseShape = new CANNON.Box(new CANNON.Vec3(32, 0.25, 32));
  const baseBody = new CANNON.Body({
    mass: 0,
    shape: baseShape,
    material: groundMatPhys
  });
  baseBody.position.set(0, -10, 0);
  world.addBody(baseBody);

  // ORIGINAL TEST BRICK
  if (makeDraggableRef) {
    makeDraggableRef(testBrick);
  }
}
`;

  html =
    html.substring(0, placeStart) +
    newFunction +
    html.substring(braceClose);

  return html;
}

// Download file
function download(html) {
  const blob = new Blob([html], { type: "text/html" });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = "InteractiveClient.html";
  a.click();
  URL.revokeObjectURL(url);
}

// Main
async function buildClient() {
  let html = await loadDefaultClient();
  html = applyMods(html);
  download(html);
}

</script>

</body>
</html>
